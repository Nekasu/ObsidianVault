# 库函数

^9cf0ab

## scanf()函数
1. scanf("%c",&a)中的%c只能接接收一个字符, 如下面这样一段代码 ^ab96d6
```c
	scanf("%c",&a);
```
如果这时候输入123, 那么只会读入字符'1'

2. 一种错误的输入方式
```c
scanf("%.2lf",&a);
```
输入时不可以指定小数的位数

3. scanf()中有普通字符时, 需将普通字符一并输入
```c
scanf("a=%db=%dc=%d", &a,&b,&c);//需要输入a=1b=2c=3或a=2 b=2 c=3
```
- 因为空格是标准的分隔符

## scanf("%c",&a)与getchar()

1. 相同:它们都仅仅能读入一个字符
2. 不同: 他们的返回值不同

scanf返回值与getchar不同，scanf返回成功赋值项个数，并将数值赋值到指定参数上，而getchar只读取一个字符并返回其ascii码，是否需要赋值取决于返回值是否赋值给某一变量。

 ## scanf("%s",str)
 
 [[云天C语言-黄皮书#^1a0154 | 字符串有四种创建方式, 其中可以使用scanf()创建]], 创建后函数会自动在末尾加上一个"\\0"

## &&与||的短路现象

1. 如果只运行前半句就行确定整个逻辑表达式的真假, 那么就不用再进行后半段的判断
```c++
int a=1,b=2,c=3;
int n;

(a=a>b)&&(b=c>b)//这句话的结果是a=0, b=2, 因为仅仅运行了前半段
(a=a<b)||(b=c>b)//这句话的结果是a=1, b=0, 因为仅仅运行了前半段
```

## 赋值语句的返回值

- 赋值语句的返回值就是==你赋给变量的值== 
```c
 while(k=0){//这个循环不会执行, 因为赋值语句的返回值是0
	 ...
 }

while(k=1){//这个循环会一直执行, 因为赋值语句的返回值是1
	...
}
```


## 一个一个读入, 直到读到回车

```c
while((a=getchar())!='\n'){
	...
}
```
- 这个语句的意思是一个一个读入输入的字符, 并进入循环, 直到遇到回车时退出循环
	- 其原理在于$getchar()$函数只能一个一个读入字符
	- 且会将空格, 回车, 制表符当作字符读入
	- getchar的返回值就是读入的字符

当输入12(回车)时, 函数将进行以下操作
1. 读入字符'1', 进入循环
2. 读入字符'2', 进入循环
3. 读入回车, 退出循环

## 逗号表达式的"返回值"

```c++
int a,b,c,d;
a = (b=1,c=2,d=3);
cout << a;
```

最终结果是3

## 复合语句中的变量

其作用域只能是在复合语句

## 自加运算符的操作数

自家运算符的操作数不一定是整型数, 如下的代码也是正确的

```c
float a=1.2;
a++;
```

但[[云天C语言-黄皮书#取余符%的运算数要求|取余运算符的操作数一定是整型数]]

# 函数

## 1 函数的申明

以下是一个函数的申明
```c
int Fun(int, int);
int Fun_2(int x, int y)
```

进行函数申明时, 必须有三个要素
1. 返回值
2. 形参类型
3. 分号

不能有
- 函数体

## 2 形参与实参
-  形参的内存分配
	- 形参只有在运行时才会分配内存

- 实参与形参的类型
	- 实参可以是常量, 变量, 表达式, 实参可以是任意类型
	- 形参只能是变量
		- 形参不可以是常量或表达式

- 形参与实参类型不一致
	- 不一致时, 以形参的类型为准

## 3 返回值

- 一个非void的函数, 如果没有写return语句
	- , 那么系统将会返回一个不确定的值
	- 不会返回若干个系统默认值, 因为返回值只有一个

## 4 main函数的参数

C语言中, main函数可以有两个参数, 第一个参数为整型变量, 第二个必须是指向字符串的

如果想要给main函数传递参数, 那么这两个参数==必须同时出现, 不能只出现一个==

### 1. 第一个形参--整型变量

main函数的第一个形参是一个整型变量, 一般写作`int argc`, argc的意思是`argument count`

这个参数负责向程序传递命令行的参数数量

### 2. 第二个形参--字符型变量

main函数的第二个形参是一个指针数组, 该数组里的指针均指向一个字符串, 一般写作`char* argv[]`或`char** argv`, argv的意思是`argument vector

这个参数负责向程序传递命令行的参数`

### 3. 一个例子

下面是一个简单的C程序，它使用argc和argv来打印出传递给程序的命令行参数：

```c
#include <stdio.h>

int main(int argc, char *argv[]) {//也可以写成char** argv
    printf("Number of arguments: %d\n", argc);
    printf("Arguments:\n");
    for (int i = 0; i < argc; i++) {
        printf("  %s\n", argv[i]);
    }
    return 0;
}
```

如果将此程序保存为`myprogram.c`，然后使用C编译器将其编译为可执行文件`myprogram`，那么您可以在命令行中运行它并传递一些参数，例如：`./myprogram arg1 arg2`。程序将打印出传递给它的参数的数量和值。

### 4. 如何传递命令行参数

在命令行中传递参数非常简单。当在命令行中运行一个程序时，只需在程序名称后面添加一些空格分隔的参数即可。
例如，如果想运行一个名为`myprogram`的程序，并传递两个参数`arg1`和`arg2`，则可以在命令行中输入以下命令：`./myprogram arg1 arg2`。

在上面的例子中，`./myprogram`是程序的名称，`arg1`和`arg2`是传递给程序的两个参数。您可以传递任意数量的参数，只需在程序名称后面添加更多的空格分隔的参数即可。

## 5. 传递数组

传递数组的方法是在函数的申明中写下一个==[[云天C语言-黄皮书#^66457f|指向数组的指针]]==, 用以接受数组

在调用函数时, 在对应的位置写下一个==数组名==即可, 编译器会==自动==将这个数组名改写成指向数组的指针, `如果只是写下一个指向数组的指针, 反而会出错`

如下例子所示
```c
//一个传递一维数组的例子
#include <iostream>
 
 using namespace std;
 
void Fun(int *p, int len){//这是一个指向一位数组的指针
    for(int i=0; i<len; i++)
        cout << p[i]<<" ";
    
    cout << '\n';
}
 
int main()
{
    int a[3]= {1,2,3};
    Fun(a, 3);//仅需要写下数组名即可, 会自动转换
    return 0;
}
```

 标准输出: 1 2 3

```c
//一个传递二维数组的例子
#include <iostream>
 using namespace std;
 
 int Fun(int (*p)[3], int row, int col){//这是一个指向二维数组的指针
     for(int i=0; i<row; i++){
         for(int j=0; j<col; j++)
            cout << p[i][j]<<" ";
        cout << '\n';
     }
 }
 
int main()
{
    int col = 3;
    int row = 3;
    
    int a[3][3]={1,2,3,4,5,6,7,8,9};
    Fun(a,3,3);//仅需要写下数组名即可, 会自动转换
    
    return 0;
}
```

标准输出：
1 2 3 
4 5 6 
7 8 9

### 1. 传递一维数组

可以用以下三中方式传递一维数组
```c
int Fun(int* p, int x);//用一个指向数组的指针传递
int Fun(int p[], int x);
int Fun(int p[5], int x);//与中括号里面数字无关
```
在第一种方法里, 我们使用了指针p保存数组的起始地址; 这个指针的名字叫做p, 其中存放是需要传递的数组的起始地址, 用图表示就是
![[Pasted image 20230313145853.png]]

在第二种方法里, 编译成会将`int p[]`编译成`int* p`

在第三种方法里, 方括号里的数字是不起作用的, 与第二种方法相同

==所以数组调用的本质就是将数组的首地址传给函数, 函数自然需要一个指针来接收==

### 2. 传递二维数组

与传递一维数组类似的是, 在向函数传递二维数组时, 在函数的定义中, 应该有一个`指向数组的指针`的形参, 因此传递二维数组的方式可以如下所示

```c
void fun(int (*a)[3]);//一个指向二维数组的指针
void fun(int a[][3]);//中括号代替了星号的作用
void fun(int a[4][3]);//第一个数"4", 是无效的数字,填10000也没问题
```

### 3. 传递数组的特殊性

1. 是否会改变原数据?
	- 会, 因为将数组的传给了函数, 没有新建副本, 所以函数直接对原数据进行了改变
2. 传递时数组名的退化
	- 当我们将数组名作为参数传递给函数时，`数组名会被自动转换为一个指向数组第一个元素的指针`。这就是为什么我们可以在函数调用时将数组名作为参数传递给函数的原因。函数接收到的实际上是一个指向数组第一个元素的指针，可以通过这个指针来访问数组中的元素。
	- 所以在传递时, 应该传递的是一个指向数组的指针
		- 但也可以将数组名传递过去, 因为数组名会自动转化成一个指向数组的指针



# 变量

1. 全局变量, 静态变量的初值在编译时指定
2. 静态变量没有赋初值的情况下, 值为0
3. 局部变量如果没有赋初值, 那么其值不确定

## auto

### 1. `auto`是什么
`auto`用于声明自动变量，这意味着该变量的生命周期仅限于其定义所在的代码块。当控制流离开该代码块时，自动变量将被销毁。`auto`是默认的存储类别，因此通常不需要显式指定。

###  2. auto的赋值时期

auto型变量在使用时才赋初值
register类型的变量页旨在使用时赋初值

### 2. 一个auto的例子
下面是一个简单的例子，演示了如何使用`auto`类型声明自动变量：

```c
#include <stdio.h>

int main() {
    for (int i = 0; i < 5; i++) {
        auto int x = 0;
        printf("x = %d\n", x);
        x++;
    }
    return 0;
}
```

在上面的代码中，我们在`for`循环内部声明了一个`auto`类型的变量`x`。由于`x`是一个自动变量，因此每次循环迭代时，它都会被重新初始化为0。因此，程序的输出将是：

```
x = 0
x = 0
x = 0
x = 0
x = 0
```

这就是一个简单的`auto`类型的用法示例。

## static-作用域小, 生命周期长

### 1. 什么是`static`, static的作用域

 `static`是一个特殊的变量类型, 其生命周期是整个程序的运行周期

### 2. static的初始化与赋值

static类型的变量在编译时时进行初始化操作, 可在运行期间重新进行赋值

- 从计算机组成原理的角度来看, 其生命周期是整个运行周期的原因是
	- `static`变量在运行时被赋初值是因为==它们存储在程序的数据段中==。
		- 数据段是程序内存中的一个区域，用于存储程序的全局变量和静态变量。
		- 当程序开始执行时，操作系统会为程序分配内存，并将程序的数据段加载到内存中。
			- 在这个过程中，静态变量会被初始化为指定的初始值。这是由编译器在编译程序时自动生成的代码来完成的。

### 3. static的作用域与生命周期

1. 作用域

`在函数内部声明`的静态变量仅在该函数内可见，但它的值在函数调用之间是保持不变的。这意味着，即使函数执行完毕并返回，静态变量的值也不会丢失，下次调用该函数时，静态变量的值仍然保持不变。

`在函数外部声明`的静态变量在整个文件内都可见。

2. 生命周期

静态变量的生命周期是整个程序运行期间

因此再次进入函数后并不会再次赋初值

### 4. static与全局变量的区别

1. 相同点
	1. 他们具有相同的生命周期
		- static的生命周期与全局变量相同, 都是整个程序运行期间
	2. 他们都是变量, 都可以被重新赋值
		- 不可重新赋值的叫做常量 `const`

2. 不同点
	- 全局变量和静态变量的主要区别在于它们的作用范围
		1. 定义在函数内静态变量的作用域就是该函数; 定义在函数外的静态变量的作用域仅仅是定义该变量的文件, 在该文件外此变量不可见
		2. 全局变量定义在函数外, 其作用域是整个程序; 一个程序可能由多个文件组成

### 5. 一个static的例子

下面是一个静态变量的例子：

```c
#include <stdio.h>

void my_function()
{
    static int static_var = 0; // 静态变量
    static_var++;
    printf("static_var = %d\n", static_var);
}

int main()
{
    my_function();
    my_function();
    my_function();
    return 0;
}
```

在上面的代码中，`static_var` 是一个静态变量，它在 `my_function` 函数内部定义，并且初始化为 `0`。每次调用 `my_function` 函数时，静态变量 `static_var` 的值都会增加 `1`，并打印出来。由于静态变量的生命周期与程序的运行时间相同，所以即使 `my_function` 函数执行完毕，静态变量 `static_var` 的值也不会被销毁，而是保留下来，等待下一次调用 `my_function` 函数时继续使用。


## 全局变量

### 1. 什么是全局变量

全局变量是在函数外定义的, 不带有static等关键词的变量

### 2. 全局变量的初始化与赋值

全局变量在程序编译时时进行初始化操作, 但是可以在运行时重新赋值

### 3. 全局变量的作用域与生命周期

全局变量的作用域是整个程序, 生命周期是整个程序的运行周期

全局变量的作用域不一定大于局部变量

### 4. 全局变量与静态变量的区别

主要区别就是作用域, 全局变量的作用域大于等于静态变量的作用域

### 5. 一个全局变量的的例子

下面是一个全局变量的例子：

```c
#include <stdio.h>

int global_variable = 10; // 全局变量

int main()
{
    printf("global_variable: %d\n", global_variable);
    return 0;
}
```

在这个例子中，`global_variable` 是一个全局变量，它被定义在 `main` 函数的外部。这意味着它可以在整个程序中被访问。


## 外部变量与内部变量的隐含类型

外部变量的隐含类型是`静态存储类` (static)
- 静态存储类别是C语言中的一种存储类别，用于定义静态变量。
- 静态变量在程序的整个生命周期内都存在，并且它们的值在程序的多次运行之间保持不变。
- 静态变量可以是全局变量，也可以是局部变量。
	- 全局静态变量在定义该变量的文件中可见
	- 而局部静态变量只在定义它的函数内可见。
- 静态存储类别可以使用关键字 `static` 显式指定。

内部变量的隐含类型是`自动存储类` (auto)
- 自动存储类别是C语言中的一种存储类别，用于定义局部变量。
- 自动变量在函数被调用时分配内存，并在函数返回时释放内存。
- 它们的值在函数调用之间不会保留。自动存储类别是局部变量的默认存储类别
- 可以使用关键字 `auto` 显式指定。

## 变量名与指针与内存地址

首先需要明确的是, 变量名可以看作是一块内存区域的别名
存放指针的内存地址和该指针中存放的内存地址不是同一块, 用图表示就是 ^bdddd2
- 这是int x=1的内存块
![[Pasted image 20230313111326.png]]
- 这是int* ptr = x的内存块
![[Pasted image 20230313152918.png]]

==值得注意的是==变量名只是地址的名字, 它并不是地址本身; &x才是地址本身; 也就是说, 我们不能把一个内存块的名字赋给一个指针型变量, 如下面的就是错误的
```c
//一段错误的代码, 错误地地址的名字赋值给了指针
int x=1;
int* p = x;

//正确的方法应该是将地址赋值给指针
int x = 1;
int* p = &x;
```



# 指针

[[云天C语言-黄皮书#变量名与指针与内存地址|在开始看指针之前, 请明确内存块的名称与存放内容之间的差异]]


## 无意义的指针操作

### 1. 地址与值相加

```c
double a[]={1,2,3,4,5,6};
double b= 6.0;

b = a + a[2];
```

### 2. 数组名是个常量

数组名是个常量, 因此不可对其进行赋值或自加自减操作, 如下面给出了两段错误的代码 ^bf4394
```c
int a[4], b[3]={1,2,3};
a=b;//错误, 数组名是常量. 不能对数组名进行赋值操作

a++;//错误, 数组名不可自加
```

以下是字符数组的错误 ^8fa52a
```c
char a[5], b[]="Hello";
a=b;//错误, 不能对数组名进行赋值操作
// 错误, 对字符串的复制应使用strcpy(a,b)函数
//即使如此, 依旧存在错误, a的长度不足以容纳b里面的字符串(因为存在\0)
```

## 2. 字符串指针 ![[云天C语言-黄皮书#6. 字符串指针]]

## 3. 指针数组与数组指针

^3b7960

C语言中有以下两个东西
```c
int* a[5];//这是一个数组, 其类型是指针
int (*a)[5];//这是一个数组, 其数组名是一个指针, 这个指针指向数组的开始
```

int \* a\[5\]是指针数组, 我们将int\* 看作一个类型, 其类型是整型指针变量, 所以a\[5\]就是一个存有5个指针的数组, 可以用"整型数组"来理解"指针数组"

第二行的就是数组指针, 如果我们将 b = \* a , 那么就有 int b\[5\]  == int (* a)\[\5], 就是一个数组, 只不过这个数组的起始地址保存在指针指向的地址里


## 4. 函数指针

### 1. 什么是函数指针

函数指针是指向函数的指针。它可以用来存储函数的地址，也可以用来调用函数。

### 2.  函数指针的申明
函数指针的类型为 `return_type (*name)(parameter_types)`，其中 `return_type` 是函数的返回类型，`name` 是指针的名称，`parameter_types` 是函数参数的类型列表。

### 3. 函数指针的使用
例如，假设我们有一个函数 `int add(int a, int b)`，那么我们可以定义一个指向它的函数指针 `int (*add_ptr)(int, int)`。然后，我们可以使用这个指针来调用 `add` 函数，例如 `int result = (*add_ptr)(3, 4)`。

```c
int fun(int x, int y){
	...
}

int main(){
	//函数指针的申明
	int (*fun_p)(int, int);

	//函数指针的赋值
	fun_p = add;

	//函数指针的调用
	int res;
	res = fun_p(1,2);
	res = (*fun_p)(1,2);
	res =fun(1,2);
}
```
函数指针在 C 语言中非常有用，它可以用来实现回调函数、函数表等高级功能。

## 5. 指针数组, 二维数组与指针的指针

### 1. 概念

指针数组: int* a\[5\]

二维数组: int b\[3\]\[4\]

指针的指针(指向指针的指针): int** p

### 2. 三者的关系

#### 1. 都可以表示二维数组

- [[云天C语言-黄皮书#^3b7960|这是指针数组]], 其中存放的内容都是指针, 每个指针可以指向一个新的数组, 从而构建成了二维数组

- 二维数组本身就是二维数组

- 指针的指针: 作为一个指针a, 它指向的是一个指针b的地址, 这个指针b可以是一个二维数组的首地址, 从而实现了二维数组, 如下图所示
![[Pasted image 20230313111857.png]]
可以使用指针的指针来访问二维数组, 如下例子所示
例如，如果有一个指向整数的指针数组 `int *array[10]`，您可以使用指针的指针 `int **ptr` 来访问数组中的元素，如下所示：

```c
int **ptr = array;
int value = **ptr; // 获取array[0]的值
```

在上面的例子中，我们将指针的指针 `ptr` 指向指针数组 `array`。然后，我们使用 `**ptr` 来访问数组中的第一个元素。您可以通过增加 `ptr` 的值来访问数组中的其他元素，例如：

```c
int **ptr = array;
int value1 = **ptr; // 获取array[0]的值
ptr++;
int value2 = **ptr; // 获取array[1]的值
```

#### 2.二维数组不是指针数组

二维数组在内存中连续存放, 但指针数组不是

指针数组可以用于表示二维数组, 但它本身不是连续存放的, 所以不是二维数组

#### 3. 指针的指针不是数组指针

数组指针是这样的 ![[云天C语言-黄皮书#3. 指针数组与数组指针]]
数组指针是一个指针, 在上例中, 数组指针的名字是a, 其中存储的是一个数组的起始地址

而指针的指针(`int** p`)的名字是p, 其中存放的是另一个指针的地址, 而[[云天C语言-黄皮书#^bdddd2|变量名可以看作是一个地址的别名]], 所以可以看作指针的指针中存放的是一个变量名, 我们可以通过这个变量名, 找到对应的内存区域

## 6. 指向数组的指针与字符串数组

现有以下代码

```c
char *a; a="abc";//1
char *b; *b = "abc";//2

char c[4] = "abc";//3
char c[4]; c = "abc";//4
char c[4]; strcpy(c,"abc");//5
```

这几种赋值方式, 1,3,5是正确的赋值方式

2的错误在于, c语言会将一个字符串隐式地转换成一个指向数组的指针, we should use a pointer to accept the string

the mistake of 4 is that, 'c' is a const type. It could not be used as a poionter which points to the array; To make it correct, we can change it to the type of "1";

### 1. 概念

这是指向指针的指针
```c
int** p;
```

这是指向数组的指针 ^66457f
```c
int *p //这是指向一维数组的指针
int (*p)[4]; // 这是指向二维数组的指针
int (*p)[4][5];// 这是指向三维数组的指针
```

### 2. 区别

顾名思义, 指向指针的指针, 本身是一个指针, 它指向的是一个指针, 指向的是一个变量指针

而指向地址的数组的指针, 其本身也是一个指针, 它指向的是一个数组, 指向的是一个常量指针

数组名和指针之间有一些重要的区别。以下是一些主要区别：

1.  数组名是常量，而指针是变量。这意味着数组名不能被重新赋值，而指针可以被重新赋值。
    
2.  当对数组名使用`sizeof`运算符时，它会返回整个数组的大小，而不是指针的大小。例如，如果您有一个`int`类型的数组`arr[10]`，则`sizeof(arr)`将返回`10 * sizeof(int)`，而不是`sizeof(int*)`。
    
3.  数组名不能进行赋值运算，而指针可以。例如，如果您有一个指针`p`和一个数组名`arr`，则`p = p + 1`是合法的，但`arr = arr + 1`是不合法的。
    
4.  数组名在函数参数中会退化为指针。这意味着当您将数组作为参数传递给函数时，该函数实际上接收到的是一个指针，而不是一个数组。
5. [[云天C语言-黄皮书#3. 传递数组的特殊性|传递数组时, 数组名会退化成指向数组的指针, 而不是指向指针的指针]]



# 字符串与字符数组

## 1. 字符串与字符数组的区别

- 在 C 语言中，字符串必须是以 '\\ 0' 做为结尾，但字符数组没有这个要求。
- 字符串一定是一个 char 的数组，但 char 的数组未必是字符串。 

## 2. '\\0' 与 字符'0'的区别

-  "\\0"是ASCII码中的第零号字符, 表示的是空字符, 是字符串的结尾
	- 字符串都会以一个空字符, 也就是"\\0"为结尾
- 字符'0'是ASCII码中的第48号字符

## 3. 字符串的创建

字符串的创建有四种方式 ^1a0154
```c
char a[]="hello";
char *str = "hello";
char str[10]; scanf("%s", str);
char scanf("%s", str);
```
这四种方法创建的字符串都将以"\\0"作为结尾

## 4. 字符串的复制

![[云天C语言-黄皮书#^bf4394]]
![[云天C语言-黄皮书#^8fa52a]]
正确复制操作见上一行的链接

## 5. 字符串的键入与输出

### 1. 字符串的键入

[[云天C语言-黄皮书#^1a0154 | 从键盘中输入的方式可以分为gets()和scanf()两种]] , 以下是它们的区别 ^30fbb0
- gets()在遇到回车时会停止读入 ^c34793
- scanf()在遇到回车, 空格, 制表符时会停止读入

这里附上getchar()与scanf()的区别 ^0d70e5
- [[云天C语言-黄皮书#scanf("%c",&a)与getchar()]]

### 2. 字符串的输出

可以通过printf()和puts()来进行字符串的输出 ^e731c0

`puts` 和 `printf("%s",a)` 都是 C 语言中用于向标准输出打印字符串的函数。`puts` 用于打印字符串并在末尾自动添加换行符。`printf("%s",a)` 则用于按照指定格式打印字符串，不会在末尾自动添加换行符。

### 6. 字符串指针

1. c语言中, 字符串就是加上了"\\0"的字符数组吗

是的，在 C 语言中，字符串就是以空字符（‘\\0’）结尾的字符数组。这个空字符用来标记字符串的结束。

附上[[云天C语言-黄皮书#2. '' 0" 与 字符'0'的区别|'\0'与 字符'0'的区别]]

2. 指向一个字符串的指针, 就相当于是指向了第一个字符的地址

### 7. 字符串与字符数组的长度

字符串的长度不包括"\\0", 但字符数组的长度包括"\\0"


## 6. 常见的字符串函数

### 1.   strlen(str)：

返回字符串 str 的长度，不包括字符串结尾的空字符。

### 2.  strcpy(dest, src)：
   
   将字符串 src 复制到 dest，包括字符串结尾的空字符。

**字符数组的先定义, 后赋值** ^85c04a
   
```c
char s[10];
//可以使用strcpy函数对s进行定义后的赋值
strcpy(s,"你好");
```

### 3.  strncpy(dest, src, n)：
 
 将字符串 src 的前 n 个字符复制到 dest，不包括字符串结尾的空字符。

### 4. strcat(dest, src)
   
   将字符串 src 拼接到 dest 后面，并添加字符串结尾的空字符。

 ### 4. strncat(dest, src, n)
 
将字符串 src 的前 n 个字符拼接到 dest 后面，并添加字符串结尾的空字符。

### 5. strcmp(str1, str2)
   
   比较字符串 str1 和 str2 是否相等，如果相等则返回 0，否则返回非零值。

### 6.    strncmp(str1, str2, n)
   
   比较字符串 str1 和 str2 的前 n 个字符是否相等，如果相等则返回 0，否则返回非零值。
   
### 7.   strchr(str, c)
   
   查找字符 c 在字符串 str 中第一次出现的位置，并返回该位置的指针。
   
### 8.    strstr(str1, str2)
   
   查找字符串 str2 在字符串 str1 中第一次出现的位置，并返回该位置的指针。

# 预定义, 预处理与宏

## 预处理的申明

1. 预处理应该以#为开头
2. 预处理命令一行只能有一个
3. 宏替换不占用运行时间
4. 宏是字符串替换, 所以在做宏的题目时, 先将字符串进行替换
5. 为了使宏定义没有歧义, ==能多加括号就多加括号==

### 文件引入#include

1. `#include ""`表示先从当前目录搜索文件, 再从系统目录所搜文件 ^884b8d
2. `#include <>`表示直接在系统目录中搜索文件

## 一个易错点!!!

typedef不是预处理命令, 它是在编译时执行的

正因为这样, typedef是一个正式的语句, 所以需要在最后加上分号

而#define只是一条预处理命令, 不是一个正式的语句, 所以不需要再最后加上分号

[菜鸟教程typedef](https://www.runoob.com/cprogramming/c-typedef.html)

C 语言提供了 **typedef** 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 **BYTE**：

>typedef unsigned char BYTE;

在这个类型定义之后，标识符 BYTE 可作为类型 **unsigned char** 的缩写，例如：

> BYTE  b1, b2;

也可以使用 **typedef** 来为用户自定义的数据类型取一个新的名字。例如，您可以对`结构体`使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：
```c
#include <stdio.h>
#include <string.h>

typedef struct Books {
	char title[50];
	char author[50]; 
	char subject[100]; 
	int book_id; 
} Book;
	
int main( ) { 
	Book book; 
	strcpy( book.title, "C 教程"); 
	strcpy( book.author, "Runoob"); 
	strcpy( book.subject, "编程语言"); 
	book.book_id = 12345; 
	
	printf( "书标题 : %s\n", book.title); 
	printf( "书作者 : %s\n", book.author); 
	printf( "书类目 : %s\n", book.subject); 
	printf( "书 ID : %d\n", book.book_id); 
	return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：

书标题 : C 教程
书作者 : Runoob
书类目 : 编程语言
书 ID : 12345

## 一些易错的宏定义题目

1. 
```c
#include<stdio.h>
#define ADD(x) x+x

int main(){
	int m=1,n=2, k=3, sum;
	sum = ADD(m+n)*k;
	printf("%d",sum);
	return 0;
}
```
此处应注意宏定义, 所以首先应该将使用到宏的地方进行字符串的替换, 如下所示
```c
sum = m+n+m+n*k
```
也即$sum=1+2+1+2*3=10$

2. 
```c
#include"stdio.h"

#define X 5
#define Y X+1
#define Z Y*X/2

int main(){
	int a = Y;
	printf("%d\n",Z);
	printf("%d\n",--a);
	return 0;
}
```
此题中有两处用到的宏定义, 所以都需要将宏进行替换, 喜欢结果如下
```c
int a = Y -> int a =X+1; ->int a = 5+1;
printf("%d\n",Z); -> printf("%d\n",Y*X/2); -> printf("%d\n",X+1*X/2);
```
所以应输出7 (换行) 5

3. 
```c
# include <stdio.h>

#define N 2
#define Y(n) ((N+1)*n)

int main(){
	int z = 2*(X+Y(5));
	printf("%d",z);
}
```
有宏定义, 先进行字符串替换
```c
int z = 2*(2+((2+1)*5))=2*(2+15)=34
```

4. 
```c
#include<stdio.h>

#define MOD(x,y) x%y

int main(){
	int z,a=15;
	float b = 100;
	z = MOD(b,a);
	printf("%d\n",z++);
}
```
由于[[云天C语言-黄皮书#取余符%的运算数要求|取余运算要求两个操作数都是整型数]], 所以这个程序有语法错误

# 运算符的优先级与要求

## 运算符的优先级

[各运算符的优先级]([(23条消息) C语言运算符优先级（超详细）_yuliying的博客-CSDN博客](https://blog.csdn.net/yuliying/article/details/72898132))

简单来说就是

括号,成员选择>单目数值运算符, 地址运算符>加减乘除运算符>&&>||>三目运算符>赋值运算符

## 取余符%的运算数要求

取余运算符要求两个操作数都是整型变量

```c
float a=10, b=10;
int c=10,d=10;
cout << a%b; //这是错误的, 因为取余只能对整型数运算
cout << c%d; // 正确
```


# 结构体

## 结构体的定义与申明

结构体定义需要加分号

结构体的定义中, 包含三个部分, 分别是
1. 结构体标识符`struct`
2. 结构体名`NAME`
3. 结构体实例`name`
这三个中, 第一个必须有, 第二个和第三个可以只有一个, 以下是三个例子

```c
#define STUDENT struct student

STUDENT{
    int num;
     float age;
 }std1;
```
这是一个正确的结构体定义, 先用`define`的预定义将`struct student`替换成了`STUDENT`, 编译时会对`STUDENT`进行字符串的替换;
在这个例子里, `student`是结构体名, `std1`是结构体实例, 这两个都出现了

```c
struct {
	int num;
	float age;
}std;
```
这是一个正确的结构体定义, 没有给出结构体的名字, 只给出了一个结构体的实例`std1`, 所以我们无法在`main`函数中使用类似于`struct student`的方式重新申明一个结构体实例

```c
struct{
	int num;
	float age;
};

struct student std1;
```
这是一个错误的结构体定义, 没有给出结构体的名字, 也没有给出结构体实例
这导致了, 虽然我们定义了一个结构体, 但是我们无法使用它

错误主要在下面的`struct student std1`, 由于没有给出结构体的名字, 自然不能用该方法定义

## 结构体数组的初值

```c
#include <stdio.h>
#include <string.h>

#define TEST struct test

TEST{
    int a;
    int b;
};

int main(){
    TEST x[10] = {0,0};//可以使用这种方式, 将结构体数组里的值全改成0
    for(int i=0; i<10; i++){
        printf("a_%d=%d,b_%d=%d",i,x[i].a,i,x[i].b);
        printf("\n");
    }
    
    return 0;
}
```
这本质上是数组在定义时, 将里面的元素全部赋值为同一个值.
在定义数组时，可以使用以下语法将所有元素初始化为同一个值：
```c
int array[10] = {value};
```
其中，`value`是要初始化的值，`10`是数组大小。例如，要将数组 `a` 的所有元素初始化为 `0`，可以这样写：
```c
int a[10] = {0};
```

如果没有指定初始值，则数组的元素将会是未定义的（也就是随机值）。

## 结构体定义的简化

#### 使用#define语句

```c
#define STUDENT struct student

STUDENT{
	string name;
	int age;
	char sex;
};
```
可以用`STUDENT`代替`struct student`

#### 使用typedef语句

```c
typedef struct student{
	string name;
	int age;
	char sex;
}student;
```

可以用`student`代替`struct student`

#### 使用typedef简化结构体指针的使用
```c
 typedef struct student{

string name;

int age;

char sex;

}*pstu;
```

-   此时pstu p等价于struct student* p, 可以不用"\*"来定义指针

# 文件

## 一些常见的文件操作函数

## fopen()

### 基本形式

>FILE\*  fopen( const char \*filename, const char \*mode );

fopen函数需要两个参数, 并返回一个FILE类型的指针

### fopen()的参数
第一个参数是文件名, 第二个参数是打开文件的方式, 其中打开方式可以是"只读, 新建写, 追加写, 读写, 新建读写, 追加读写,"以及对应的二进制模式
1. r: 
	- read, 只读模式
2. w: 
	- write, 只写模式(新建写), 新建一个文件以写入, 如果文件已存在, 则会删除原文件中的所有内容
	- 只写模式下, 不可读取文件的数据
3. a: 
	- 追加写模式, 从文件的末尾开始写入数据, 如果没有该文件, 则会新建文件
	1. 值得注意的是, 在追加模式下是==可以从文件中读数据的==
		- 但是只能从文件的末尾开始读取
		- 如果尝试从文件==开头==读取，那么读取的数据将==是文件追加后的内容==，而不是文件中原有的内容
	2. 值得注意的是, 在追加模式下写数据, 总会被写到文件末尾 
4. r+
	1. 读写模式
5. w+
	1. (新建)读写模式
6. a+
	1. 追加读写模式
		- 以 "a+" 模式打开文件时，如果文件不存在，则会尝试创建一个新的文件。
		- 如果文件已经存在，文件指针会被设置在文件的末尾，也就是在追加数据的位置。
	2. 与'a'的区别
		1. 追加模式只能读自己追加的内容, 但a+可以读原来的内容
	3. a+模式只会写到最后
		- 以追加模式打开文件时，写入的数据总是会追加到文件的末尾，
		- 而不是覆盖原有的数据。
		- 如果需要修改文件中的数据，则需要使用读写模式。
7. 二进制
	- 如果想用二进制的方式打开文件, 加上关键字"b"即可

### r+和w+的区别

r+和w+都是读写模式, 但是有一些区别
1. 打开文件时
	- 如果文件不存在
		- r+返回空指针
		- w+新建一个文件, 返回新建文件的指针
	- 如果文件存在
		- r+返回原文件指针
		- w+删除原文件并新建一个, 返回新建的指针

这导致r+和w+在应用上的区别
- r+一般用于需要`保留`原文件内容的读写
- w+一般用于需要`删除`原文件的读写

### 文件打开失败

如果fopen打开文件失败, 会返回NULL(早期版本返回0)

### 一个fopen/fclose的例子

```c
#include <stdio.h>

int main() {
    FILE *fp;

    // 打开一个名为 example.txt 的文件并写入内容
    fp = fopen("example.txt", "w");
    fprintf(fp, "Hello World!");
    fclose(fp);

    return 0;
}
```

## fclose()

关闭文件, 很简单, 但很重要, 每一个fopen都应该对应一个fclose, 下面是一个例子

![[云天C语言-黄皮书#一个fopen/fclose的例子]]

## fseek()

### 基本形式

fseek 函数是 C 标准库中的一个文件操作函数，用于设置文件指针的位置。

在打开文件后，文件指针通常指向文件的开头。通过调用 fseek 函数，可以将文件指针移动到文件的任意位置，以便进行读取或写入操作。fseek 函数的原型如下：

>int fseek(FILE \*stream, long offset, int whence);

其中，stream 是指向 FILE 结构体的指针，它表示要操作的文件；

offset 是要移动的偏移量，它可以是一个正整数或负整数，表示要移动多少个字节；

whence 表示偏移量的起点，它可以取以下三个值之一：
-   SEEK_SET(或数字0)：从文件开头开始偏移，即偏移量是从文件开头算起的字节数；
-   SEEK_CUR(或数字1)：从文件指针当前位置开始偏移，即偏移量是从文件指针当前位置算起的字节数；
-   SEEK_END(或数字2)：从文件末尾开始偏移，即偏移量是从文件末尾算起的字节数。


下面是一个简单的 fseek 函数的示例，演示如何使用 fseek 函数将文件指针移动到文件的末尾：

```c
#include <stdio.h>

int main() {
    FILE *fp;

    fp = fopen("file.txt", "r");

    if (fp == NULL) {
        perror("Error opening file");
        return 1;
    }

    /* 将文件指针移动到文件末尾 */
    fseek(fp, 0L, SEEK_END);

    /* 在文件末尾添加新的数据 */
    fputs("New data", fp);

    fclose(fp);
    return 0;
}

```
在上面的示例中，fseek 函数将文件指针移动到文件的末尾，以便向文件中添加新的数据。

在一个数后面直接加上L, 就可以使之变成long型的数

## rewind()

rewind()的作用是将文件指针指向文件开头, 与
```c
fseek(fp, 0L, 0);
```
的作用相同

## ftell()

用于获取文件指针的当前位置, 返回值是一个long int, 表示当前位置距离文件开头的字节数

## fread与fwrite

`fwrite` 和 `fread` 是 C 标准库中用于文件读写的函数。它们分别用于向文件中写入数据和从文件中读取数据。
# ASCII

## 大小写转换

'a'-32 -> 'A'

'A'+32 -> 'a'

## 数字与字符转化

0 + '0' -> '0'

1+ '0' -> '1'




# 程序题注意事项

1. 函数调用时, 分清是n还是N
2. 矩阵变化找变换前后相同数字的下标关系
3. 逆序数, 回文数等这种需要将数组第一个和最后一个对应起来进行比较的题目, 注意数组长度需要减一, 如下例所示
```c
/*下列给定程序中函效fun的功能是先将在字符串s中的字符串按逆序存放到t串中,然
后把s中的字符按正序连按到t串的后面, 例如,当s中的学符串为ABCDE时,则t中的字符串应
为EDCBAABCDE. 请改正程序中的错误, 使它能得出正确的结果. */
#include <stdlib. h>
#include <stdio.h>
#include <string.h>
void fun (char *s, char *t )
{
	int i,sl;
	sl-strlen (s);
	for (i=0;i<sl;i++)
		/**************ERROR**************/
		t[i] =  S[s1-1];    //此处的正确答案是t[i]=s[s1-1-i];
	for (i-0;i<s1.i++)
		t[s1+i]=s[i];
	/****************ERROR****************/
	t[2*s1]=0;

int main()
{
	char s[100], t[100];
printf("InPlease enter string s: ");
scanf("%s", s);
/*****************ERROR*****************/
fun (s[100], t[100]):
printf ("The result is: %s\n.t);
return 0;
```

4. 如果遇见"环"状结构, 请记得取余运算
	- 如程序改错第8题
5. 如果if语句出错, 那么可能是以下的问题
	1. 错将判等写成赋值
	2. 错将不等写成等于
	3. 错将相等写成不等
6. 双重循环中, 如果内循环用到了外循环的计数变量, 请注意不要让内层循环越界, 如下所示
```c
for(int i=0; i<m; i++){//错误, 应考虑内存循环不越界, 此处应为i<m-1
	for(int j=0; j<m-i-1; j++)
}
```

7. 遇到需要用递推公式的题目, 需要注意
	1. 表示加和的那个变量是从第几个开始加的
	2. 最终输出的值是加和的几倍?

做出递归公式的程序题的关键是找前一项与后一项之间的递推关系

如下例题

已知以下公式
$$\frac{\pi}{2}=1+\frac{1}{3}+\frac{1}{3}\times\frac{2}{5}+\frac{1}{3}\times\frac{2}{5}\times \frac{3}{7}+\frac{1}{3}\times\frac{2}{5}\times \frac{3}{7}\times \frac{4}{9}+\cdots$$
下面程序的功能是根据上述公式输出满足精度要求的$eps$的$\pi$值, 请填空使程序完整 ^9b1e7c
```c
#include<stdio.h>

int main(){
	double s=1.0. eps, t-1.0;
	int n;
	scanf("%lf",&eps);
	for(int n=1; __________; n++){
			t = ___________;
			s += t;
	}
	____________;
	return 0;
}
```
答案: 
- $t>eps$
- $t*n/(2*n+1);$
- printf("%lf",2\*s)


# 需要再看的题目

1. ![[SmartSelect_20230318_164245_Samsung Notes 1.jpg]]
2. ![[云天C语言-黄皮书#^9b1e7c]]
3. ![[SmartSelect_20230318_164601_Samsung Notes.jpg]]

## 有关fseek, rewind

```c
//以下这段代码的运行结果是什么?
#include<stdio.h>
#include<stdlib.h>

int main(){
	FILE *fp;
	char s1[]="China", s2[]="Beijing";
	
	fp = fopen("test.dat","wb+");
	fwrite(s2,7,1,fp);
	fseek(fp,0,0);
	fwrite(s1,5,1,fp);
	fclose(fp);
	return 0;
}
```

$fwrite(s2,7,1,fp)$是向文件 `fp` 写入数据，它的参数依次是：

-   `s2`：要写入的数据的地址；
-   `7`：每个数据块的大小，以字节为单位；
-   `1`：要写入的数据块的数量；
-   `fp`：要写入数据的文件的指针。

因此，这行代码的意思是向文件 `fp` 写入一个大小为 7 字节的数据块，这个数据块的内容来自于 `s2` 数组。

$rewind(fp)$将文件指针指向了文件开头, 在文件开头再次写入数据时, 会导致原有数据覆盖($fseek()$也会有类似的现象)

>结果: Chinang

## 有关读入数据

```c
#include<stdio.h>
#include<stdlib.h>

int main(){
    FILE *fp;
    int a[10]={1,2,3},n;
    fp = fopen("test.dat","w");
    for(int i=0; i<3; i++){
        fprintf(fp,"%d ",a[i]);
    }
    //fprintf(fp,"\n");
    fclose(fp);
    fp=fopen("test.dat","r");
    fscanf(fp,"%d",&n);
    fclose(fp);
    printf("%d\n",n);
    return 0;
}
```

>输出结果: 123

# 其他函数

1. 求绝对值函数
```c
#include<math.h>

int a = -10;
double b = -10.5;
int abs_a = abs(a);//abs函数用于求整型数的绝对值
double fabs_b = fabs(b);//fabs用于求浮点数的绝对值
```