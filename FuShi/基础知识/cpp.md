# 继承

[C++ 继承 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cplusplus/cpp-inheritance.html)

# 一些概念

## 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，用于创建一个新对象，其内容与现有对象相同。它通常采用引用参数传递要复制的对象，并且必须能够正确处理所有数据成员的复制。拷贝构造函数的语法如下：

```cpp
class MyClass {
public:
    MyClass(); // 默认构造函数
    MyClass(const MyClass& other); // 拷贝构造函数
    // 其他成员函数和数据成员
};

MyClass::MyClass() {
    // 默认构造函数的实现
}

MyClass::MyClass(const MyClass& other) {
    // 拷贝构造函数的实现
    // 将other的数据成员复制到当前对象
}

```

1.  什么时候需要使用拷贝构造函数？
	1. 当需要将现有对象传递给函数或创建一个新对象时，拷贝构造函数就会被调用。例如，当使用一个现有对象初始化另一个对象时，或者当将对象作为参数传递给函数时。
    
2.  拷贝构造函数的参数类型是什么？ 
	1. 拷贝构造函数的参数应该是一个常引用，它表示要复制的对象。参数应该是一个常引用而不是值或非常量引用，因为值参数将调用拷贝构造函数本身，而非常量引用参数可能会被修改。
    
3.  如何实现拷贝构造函数？
	1. 拷贝构造函数应该将一个现有对象的所有数据成员复制到一个新的对象中。在实现时，可以使用成员初始化列表或循环遍历对象的数据成员来完成复制操作。
    
4.  编译器是否提供默认的拷贝构造函数？
	1. 是的，如果没有显式定义拷贝构造函数，则编译器会提供一个默认的拷贝构造函数，它执行浅拷贝操作。但是，如果类中包含指针等动态分配的资源，则需要显式实现拷贝构造函数以避免浅拷贝带来的问题。

##  友元函数

友元函数是一个非成员函数，但它被授权访问一个类的私有成员和保护成员。它可以在函数定义前加上`friend`关键字来声明，以便将其声明为友元函数。友元函数可以是一个全局函数、另一个类的成员函数或另一个类的友元函数。

友元函数有以下特点：

1.  友元函数可以访问它所属类的所有成员，包括私有成员和保护成员，不受访问权限控制。
    
2.  友元函数并不是类的成员函数，它不能直接访问类的this指针，也不能调用类的成员函数，但可以通过对象的引用或指针间接访问。
    
3.  友元函数的声明必须在类的内部，定义可以在类的内部或外部。
    

下面是一个友元函数的例子：


```cpp
class MyClass {
private:
    int value;
public:
    MyClass(int v) : value(v) {}
    friend void printValue(MyClass obj);
};

void printValue(MyClass obj) {
    cout << "The value of MyClass is: " << obj.value << endl;
}

int main() {
    MyClass obj(42);
    printValue(obj);
    return 0;
}
```


在这个例子中，`printValue()`函数被声明为`MyClass`的友元函数。因此，它可以访问`MyClass`类的私有成员`value`。在`main()`函数中，我们创建了一个`MyClass`对象并将其传递给`printValue()`函数，它可以打印出对象的`value`值。

需要注意的是，友元函数破坏了类的封装性，过度使用友元函数会使程序变得复杂，不易维护。所以，在使用友元函数时需要慎重考虑。

## this指针

this指针是C++中一个特殊的指针，它指向当前对象的地址。每个成员函数都有一个隐式的this指针，指向调用该函数的对象。当成员函数被调用时，this指针会自动传递给成员函数，使成员函数能够访问对象的成员变量和成员函数。

在C++中，使用this指针可以实现以下功能：

1.  在成员函数中访问对象的成员变量和成员函数，因为成员变量和成员函数都属于对象本身，只能通过this指针来访问。
    
2.  在成员函数中返回对象本身，这在实现链式编程时非常有用。比如，可以将赋值操作的返回值设为对象本身，这样就可以使用连续的赋值操作。
    
3.  在成员函数中判断对象是否相同，因为每个对象的地址都不同，可以通过比较对象的地址来判断对象是否相同。
    

下面是一个使用this指针的例子：

```cpp
class MyClass {
private:
    int value;
public:
    MyClass(int v) : value(v) {}
    MyClass& add(int v) {
        this->value += v;
        return *this;
    }
    bool equal(const MyClass& obj) {
        return this == &obj;
    }
};

int main() {
    MyClass obj1(42);
    MyClass obj2(42);
    obj1.add(10);
    cout << obj1.equal(obj2) << endl;  // 输出0，因为obj1和obj2是不同的对象
    cout << obj1.equal(obj1) << endl;  // 输出1，因为obj1和obj1是同一个对象
    return 0;
}

```

在这个例子中，我们定义了一个`MyClass`类，它有一个成员变量`value`和一个成员函数`add()`。`add()`函数将传入的参数加到对象的`value`中，并返回对象本身。我们使用`this`指针来访问对象的`value`成员。在`main()`函数中，我们创建了两个`MyClass`对象，并调用`add()`函数。然后，我们使用`equal()`函数来判断两个对象是否相同，这里使用了`this`指针来比较对象的地址。


## 构造函数的顺序

关键: 先把需要的原料准备好, 在执行自己的, 自己的永远在最后

### 包含其他类的对象的类

构造时: 先成员的构造, 后自己的构造

析构时: 先自己, 后成员

在C++中，如果一个类中包含了其他类的对象作为成员，那么构造函数的执行顺序是按照成员在类中的声明顺序来确定的。具体来说，如果一个类中包含了多个成员对象，那么它们的构造函数的执行顺序与它们在类中声明的顺序相同，而析构函数的执行顺序则与构造函数的执行顺序相反。

下面是一个示例代码，展示了这个过程：
```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "Constructing A\n"; }
    ~A() { cout << "Destructing A\n"; }
};

class B {
public:
    B() { cout << "Constructing B\n"; }
    ~B() { cout << "Destructing B\n"; }
};

class C {
public:
    C() { cout << "Constructing C\n"; }
    ~C() { cout << "Destructing C\n"; }
private:
    A a;
    B b;
};

int main() {
    C c;
    return 0;
}

```

在这个例子中，类`C`中包含了两个成员对象`a`和`b`，它们分别是类`A`和类`B`的对象。

1. 当==创建==类`C`的对象`c`时，会先调用类`A`的构造函数，再调用类`B`的构造函数，最后才调用类`C`的构造函数。
2. 当==销毁==对象`c`时，会先调用类`C`的析构函数，再调用类`B`的析构函数，最后才调用类`A`的析构函数。

需要注意的是，如果一个成员对象是用指针或引用的方式声明的，那么它的构造函数和析构函数的执行顺序与指针或引用的初始化顺序有关，而不是与成员在类中的声明顺序有关。

### 基类和派生类

先基类后派生类

在创建派生类的对象时，基类和派生类的构造函数的顺序是先调用基类构造函数，然后再调用派生类构造函数。

具体来说，当创建一个派生类的对象时，会按照以下步骤执行：

1.  分配内存空间：首先，会为派生类对象分配内存空间。这个内存空间包括了派生类对象中所有成员变量和函数的存储空间。
    
2.  调用基类构造函数：接下来，会调用基类的构造函数，以初始化基类成员变量。这个过程会按照基类构造函数的声明顺序依次执行，不管这些成员变量是在派生类中还是基类中声明的。
    
3.  调用派生类构造函数：最后，会调用派生类的构造函数，以初始化派生类自身的成员变量。这个过程会按照派生类构造函数的声明顺序依次执行。
    

需要注意的是，当派生类构造函数执行时，它可以访问基类中的成员变量，但是基类中的构造函数不能访问派生类中的成员变量。此外，如果派生类没有显式地调用基类构造函数，那么编译器会自动调用默认的基类构造函数。

以下是一个简单的示例代码，展示了派生类对象构造函数的执行顺序：
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Base constructor called\n";
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived constructor called\n";
    }
};

int main() {
    Derived d;
    return 0;
}

```

在这个例子中，类`Derived`是从类`Base`派生而来的。当创建派生类对象`d`时，会先调用基类`Base`的构造函数，然后再调用派生类`Derived`的构造函数。运行程序，输出结果如下：

```
Base constructor called
Derived constructor called
```

可以看到，构造函数的执行顺序是先调用基类构造函数，然后再调用派生类构造函数。


## 重载与重写

### 函数重载

我喜欢读作重载(体重的重), 这样表示一个函数由于参数列表不同导致一个函数有多个功能, `身负重担`

函数重载是指在同一个作用域内，可以定义多个同名函数，但它们的参数个数、类型或顺序不同。在调用这些同名函数时，编译器会根据传入的参数类型和数量，自动匹配并调用对应的函数，从而实现函数重载的效果。

函数重载的语法形式如下
```scss
返回类型 函数名 (参数列表1);
返回类型 函数名 (参数列表2);
返回类型 函数名 (参数列表3);
//...

```

其中，参数列表包括参数类型和参数名，多个参数之间用逗号隔开。在参数列表中，参数的顺序、类型、个数都可以不同。下面是一个简单的函数重载的例子：

```cpp
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int main() {
    int x = 2, y = 3;
    double d1 = 1.2, d2 = 3.4;
    cout << add(x, y) << endl;        // 输出 5
    cout << add(d1, d2) << endl;      // 输出 4.6
    return 0;
}

```

在上面的例子中，我们定义了两个名为`add`的函数，一个用于两个整数相加，一个用于两个浮点数相加。在`main()`函数中，我们分别用整数和浮点数调用了这两个函数，编译器会根据参数类型自动匹配相应的函数并进行调用。

需要注意的是，函数重载并不仅仅是参数列表不同，函数的返回类型和函数的const属性也可以是函数重载的区别。在使用函数重载时，我们需要注意函数的参数列表的类型、数量、顺序等，以免出现二义性。

==注意! 重载的函数的参数列表一定不同! 仅仅返回值不同的不能算作重载, 因为无法区分调用的是 哪个函数==

### 函数重写

[[cpp#运行时多态与虚函数]]

函数重写是一种实现函数覆盖的方式, 不使用虚函数就不能完成函数重写, 但不使用虚函数可以实现函数覆盖

函数重写是指在继承关系中，派生类重新定义了基类中的虚函数，使得在使用派生类对象调用该虚函数时，会优先调用派生类中的函数实现，而不是基类中的实现。

函数重写需要满足以下条件：

1.  基类中的函数必须是虚函数，也就是在函数声明前加上`virtual`关键字。
2.  派生类中的函数必须与基类中的虚函数有相同的函数名、参数列表和返回类型，并且也必须加上`virtual`关键字。
3.  派生类中的函数可以使用`override`关键字进行标识，表示该函数是对基类虚函数的重写，如果基类中不存在该虚函数，则会发生编译错误。

函数重写的语法形式如下：

```cpp
class Base {
public:
    virtual void foo();
};

class Derived : public Base {
public:
    void foo() override;
};

```

在上面的例子中，`Base`类中定义了一个虚函数`foo`，而`Derived`类继承了`Base`类，并重新定义了`foo`函数。在派生类中，我们使用了`override`关键字，表示该函数是对基类中虚函数的重写。

需要注意的是，函数重写只对虚函数起作用，普通的非虚函数无法被重写。在使用函数重写时，我们需要特别注意函数名、参数列表和返回类型的匹配，否则会发生编译错误。

### 函数重写与函数覆盖

函数重写是一种实现函数覆盖的方式, 不使用虚函数就不能完成函数重写, 但不使用虚函数可以实现函数覆盖

# 虚

>定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

## 虚基类和虚函数 

虚基类和虚函数的关键字为什么是一样的是因为它们都是用来实现多态的关键字，虚基类主要用于解决菱形继承问题，而虚函数则是实现动态绑定和多态的一种重要方式。

虚基类和虚函数的联系在于，它们都可以实现多态。当一个类作为虚基类时，它的成员变量只有一个实例，无论有多少个派生类继承自它，都只有一个共享的实例。而当一个函数被声明为虚函数时，它的调用将在运行时进行动态绑定，实现基于实际对象类型的多态。

虚基类和虚函数都是实现多态的机制，但是它们的应用场景不同。虚基类主要用于解决菱形继承问题，而虚函数则是实现对象的多态性，让程序在运行时根据实际对象类型来决定调用哪个函数。

## 运行时多态与虚函数

[[cpp#函数重写|虚函数与函数重写]]

运行时多态（Runtime Polymorphism）是指==在程序运行时，根据实际的对象类型来调用相应的函数，从而实现多态性的一种机制。==

在C++中，运行时多态是通过虚函数（Virtual Function）来实现的。虚函数是在基类中定义的一个函数，它可以被派生类重写，使得在运行时能够根据对象的实际类型调用相应的函数。当一个函数被声明为虚函数时，在使用派生类对象的指针或引用调用该函数时，将根据对象的实际类型来确定调用哪个函数。

具体来说，如果一个基类中的函数被声明为虚函数，那么在派生类中重写这个函数时，需要在函数声明前面加上`virtual`关键字。例如：

```cpp
class Shape {
public:
    virtual void draw() {
        // 基类中的虚函数
    }
};

class Circle : public Shape {
public:
    void draw() override {
        // 派生类中重写的虚函数
    }
};

```

在上面的代码中，类`Shape`中的函数`draw()`被声明为虚函数。在派生类`Circle`中，我们通过关键字`override`来重写了这个虚函数。当我们使用基类指针或引用调用`draw()`函数时，会根据对象的实际类型来确定调用哪个函数。例如：

```cpp
int main() {
    Shape* shape1 = new Shape();
    Shape* shape2 = new Circle();
    shape1->draw();  // 调用基类中的虚函数
    shape2->draw();  // 调用派生类中重写的虚函数
    delete shape1;
    delete shape2;
    return 0;
}
```

在上面的代码中，我们创建了两个指向基类`Shape`和派生类`Circle`的指针`shape1`和`shape2`。在调用`draw()`函数时，`shape1->draw()`会调用基类中的虚函数，而`shape2->draw()`会调用派生类中重写的虚函数。这就是运行时多态的一种表现形式。

需要注意的是，为了实现运行时多态，基类中的虚函数必须是公有的，并且它们的参数和返回值类型也必须相同。此外，析构函数也可以声明为虚函数，以确保在销毁派生类对象时能够正确地调用析构函数。


## 虚基类

### 什么是虚基类? 虚基类有什么用?

#### 什么是虚基类

[虚基类是在继承时在继承类型public之前用virtual修饰的基类。虚基类的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员](http://c.biancheng.net/view/2280.html)[1](http://c.biancheng.net/view/2280.html)[2](https://www.dotcpp.com/course/78)。

#### 虚基类有什么用


虚基类是在多重继承中用来解决由于多次继承同一个基类而引发的二义性问题的一种机制。虚基类是通过使用虚继承来实现的。

在使用虚基类的情况下，如果派生类之间存在多次继承同一个基类，那么这个基类在继承体系中只会出现一次，并且在最终的派生类中只会保留一个基类子对象。这样，就可以避免因为多次继承同一个基类而导致的数据冗余和二义性问题。

虚基类有以下几个特点：

1.  虚基类必须是直接基类，即不能通过间接继承而得到。
    
2.  虚基类的构造函数由最终派生类调用。
    
3.  虚基类的构造函数只会被调用一次。
    
4.  虚基类的成员变量在最终派生类中只有一个副本。
    

虚基类的使用可以使继承体系更加清晰和易于理解，但是过度使用虚基类也会增加程序的复杂性。虚继承的使用需要慎重考虑，应该在必要的情况下才使用。

### 一个例子

下面给出一个使用虚基类的例子，用于演示虚继承的作用。

假设我们有一个“人”类（Person），其中包含了姓名和年龄两个成员变量，以及显示姓名和年龄的成员函数。现在我们要定义一个“学生”类（Student），它除了继承“人”类的姓名和年龄外，还有一个班级编号的成员变量和一个显示班级编号的成员函数。

在这种情况下，我们可以定义一个“学生”类，它从“人”类继承姓名和年龄，并且把“人”类定义为虚基类，这样可以保证在最终派生类中只有一个“人”类对象。

```cpp
class Person
{
public:
    Person(string name, int age) : m_name(name), m_age(age) {}
    virtual void display()
    {
        cout << "Name: " << m_name << endl;
        cout << "Age: " << m_age << endl;
    }
protected:
    string m_name;
    int m_age;
};

class Student : virtual public Person
{
public:
    Student(string name, int age, int classID) : Person(name, age), m_classID(classID) {}
    void displayClassID()
    {
        cout << "Class ID: " << m_classID << endl;
    }
protected:
    int m_classID;
};

```

在上面的代码中，我们使用了`virtual public`关键字来表示“Person”类是一个虚基类，并且在“Student”类中使用了虚继承。

这样，当我们定义一个最终派生类，例如“大学生”类（CollegeStudent），它从“学生”类继承班级编号，并且还有一个学校名称的成员变量和一个显示学校名称的成员函数。在最终派生类中，只有一个“人”类对象，这样可以避免因为多次继承“人”类而导致的数据冗余和二义性问题。

```cpp
class CollegeStudent : virtual public Student
{
public:
    CollegeStudent(string name, int age, int classID, string school) : Person(name, age), Student(name, age, classID), m_school(school) {}
    void displaySchool()
    {
        cout << "School: " << m_school << endl;
    }
private:
    string m_school;
};

```

在上面的代码中，我们在“CollegeStudent”类中使用了虚继承，这样可以保证在“CollegeStudent”类中只有一个“人”类对象。同时，“CollegeStudent”类从“学生”类继承班级编号，并且还有一个学校名称的成员变量和一个显示学校名称的成员函数。由于“学生”类从“人”类继承，因此“CollegeStudent”类也继承了“人”类的姓名和年龄。

## 抽象类与虚函数与纯虚函数

抽象类是指含有纯虚函数的类，纯虚函数是指在基类中定义但没有实现的虚函数，也就是只有函数原型，没有函数体。抽象类不能实例化，只能作为基类来派生出新的类。派生类必须实现基类中的纯虚函数，否则派生类也会成为抽象类。

抽象类的作用是提供一种接口，规定了派生类必须实现的接口函数，使得代码具有良好的可扩展性和可维护性。在设计大型的软件系统时，通常使用抽象类来设计框架和接口，以便于在以后的开发中可以轻松地扩展和修改代码。

参考:
[[cpp#运行时多态与虚函数|虚函数]]